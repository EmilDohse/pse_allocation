// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package controllers;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

import org.apache.commons.mail.EmailException;

import com.google.inject.Inject;

import data.Allocation;
import data.ElipseModel;
import data.GeneralData;
import data.Semester;
import data.Student;
import data.Team;
import exception.DataException;
import notificationSystem.Notifier;
import play.data.DynamicForm;
import play.data.FormFactory;
import play.mvc.Controller;
import play.mvc.Result;

/************************************************************/
/**
 * Dieser Controller ist für das Bearbeiten der Http-Requests zuständig, welche
 * beim Editieren einer Einteilung abgeschickt werden.
 */
public class AdminEditAllocationController extends Controller {

    @Inject
    FormFactory                                 formFactory;

    @Inject
    Notifier                                    notifier;

    /**
     * Commando Stack. Static, weil Play nicht garantiert, dass es nur einen
     * Controller gibt.
     */
    private static Deque<EditAllocationCommand> undoStack      = new ArrayDeque<>();

    private static final String                 ALLOCATION_ID  = "allocationID";
    private static final String                 INTERNAL_ERROR = "error.internalError";

    /**
     * Diese Methode editiert die Einteilung.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result editAllocation() {
        DynamicForm form = formFactory.form().bindFromRequest();
        if (form.data().isEmpty()) {
            return badRequest(ctx().messages().at(INTERNAL_ERROR));
        }
        String[] selectedIdsString = MultiselectList.getValueArray(form,
                "selected-students");
        ArrayList<Integer> selectedIds = new ArrayList<>();
        for (String s : selectedIdsString) {
            try {
                selectedIds.add(Integer.parseInt(s));
            } catch (NumberFormatException e) {
                flash("error", ctx().messages().at(INTERNAL_ERROR));
                return redirect(
                        controllers.routes.AdminPageController.resultsPage());
            }
        }
        if (form.get("move") != null) {
            return moveStudents(form, selectedIds);
        } else if (form.get("exchange") != null) {
            return swapStudents(form, selectedIds);
        } else {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
    }

    /**
     * Diese Methode tauscht zwei Studenten, welche der Administrator vorher in
     * einem Formular ausgewählt hat. Ein Tausch innerhalb eines Teams wird
     * nicht unterbunden, hat jedoch keine Auswirkung. Anschließend wird der
     * Administrator auf die Seite zur Einteilungs-Bearbeitung zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result swapStudents(DynamicForm form, List<Integer> ids) {
        // TODO evtl Email, wenn Einteilung final ist?
        String allocationIdString = form.get(ALLOCATION_ID);
        int allocationId;
        try {
            allocationId = Integer.parseInt(allocationIdString);
        } catch (NumberFormatException e) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        Allocation allocation = ElipseModel.getById(Allocation.class,
                allocationId);

        if (ids.size() != 2) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }

        Student firstStudent = ElipseModel.getById(Student.class, ids.get(0));
        Student secondStudent = ElipseModel.getById(Student.class, ids.get(1));
        SwapStudentCommand command = new SwapStudentCommand(allocation,
                firstStudent, secondStudent);
        command.execute();
        undoStack.push(command);

        return redirect(controllers.routes.AdminPageController.resultsPage());
    }

    /**
     * Diese Methode verschiebt einen oder mehrere ausgewählte Studenten in ein
     * anderes Team. Das Verschieben in das gleiche Team wird nicht unterbunden,
     * hat jedoch keine Auswirkung. Anschließend wird der Administrator auf die
     * Seite zur Einteilungs-Bearbeitung zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result moveStudents(DynamicForm form, List<Integer> ids) {
        // TODO evtl Email, wenn Einteilung final ist?
        String teamIdString = form.get("project-selection");
        String allocationIdString = form.get(ALLOCATION_ID);
        int allocationId;
        int teamId;
        try {
            teamId = Integer.parseInt(teamIdString);
            allocationId = Integer.parseInt(allocationIdString);
        } catch (NumberFormatException e) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }

        Team newTeam = ElipseModel.getById(Team.class, teamId);
        Allocation allocation = ElipseModel.getById(Allocation.class,
                allocationId);

        List<Student> students = new ArrayList<>();
        for (int id : ids) {
            Student s = ElipseModel.getById(Student.class, id);
            students.add(s);
        }

        if (students.isEmpty()) {
            flash("error", ctx().messages().at("admin.edit.noStudentSelected"));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }

        MoveStudentCommand command = new MoveStudentCommand(allocation,
                students, newTeam);
        command.execute();
        undoStack.push(command);

        return redirect(controllers.routes.AdminPageController.resultsPage());
    }

    /**
     * Diese Methode veröffentlicht eine Einteilung. Dazu gehört, die Einteilung
     * als final zu deklarieren und Betreuer und Studenten per E-Mail über deren
     * Einteilung zu informieren. Der Administrator wird anschließend auf die
     * Einteilungs-Bearbeitungs-Seite zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result publishAllocation() {
        // TODO popup warnung
        DynamicForm form = formFactory.form().bindFromRequest();
        if (form.data().isEmpty()) {
            return badRequest(ctx().messages().at(INTERNAL_ERROR));
        }
        String allocationIdString = form.get(ALLOCATION_ID);
        int allocationId;
        try {
            allocationId = Integer.parseInt(allocationIdString);
        } catch (NumberFormatException e) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        Allocation allocation = ElipseModel.getById(Allocation.class,
                allocationId);
        Semester semester = GeneralData.loadInstance().getCurrentSemester();
        if (semester.getFinalAllocation() != null) {
            flash("error", ctx().messages().at("admin.edit.noFinalAllocation"));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        semester.doTransaction(() -> {
            semester.setFinalAllocation(allocation);
        });
        try {
            notifier.notifyAllUsers(allocation);
        } catch (EmailException e) {
            // TODO
            e.printStackTrace();
        }
        return redirect(controllers.routes.AdminPageController.resultsPage());
    }

    /**
     * Diese Methode erstellt eine Kopie einer kompletten Einteilung. Diese
     * Funktion ist dafür gedacht, dass der Administrator sehen kann, ob durch
     * seine manuelle Änderungen ein besseres Ergebnis entstand. Der
     * Administrator wird anschließend auf die Seite zur Einteilungs-Bearbeitung
     * zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result duplicateAllocation() {
        DynamicForm form = formFactory.form().bindFromRequest();
        if (form.data().isEmpty()) {
            return badRequest(ctx().messages().at(INTERNAL_ERROR));
        }
        String allocationIdString = form.get(ALLOCATION_ID);
        int allocationId;
        try {
            allocationId = Integer.parseInt(allocationIdString);
        } catch (NumberFormatException e) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        Allocation allocation = ElipseModel.getById(Allocation.class,
                allocationId);
        try {
            Allocation clonedAllocation = new Allocation(allocation);
            clonedAllocation.save();
            Semester semester = GeneralData.loadInstance().getCurrentSemester();
            semester.doTransaction(() -> {
                semester.addAllocation(clonedAllocation);
            });
        } catch (DataException e) {
            // TODO
            e.printStackTrace();
        }
        return redirect(controllers.routes.AdminPageController.resultsPage());
    }

    /**
     * Diese Methode löscht eine bereits vorhandene Einteilung. Der
     * Administrator wird anschließend auf die Seite zur Einteilungs-Bearbeitung
     * zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result removeAllocation() {
        DynamicForm form = formFactory.form().bindFromRequest();
        if (form.data().isEmpty()) {
            return badRequest(ctx().messages().at(INTERNAL_ERROR));
        }
        String allocationIdString = form.get(ALLOCATION_ID);
        int allocationId;
        try {
            allocationId = Integer.parseInt(allocationIdString);
        } catch (NumberFormatException e) {
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        Allocation allocation = ElipseModel.getById(Allocation.class,
                allocationId);
        if (allocation.equals(GeneralData.loadInstance().getCurrentSemester()
                .getFinalAllocation())) {
            flash("error",
                    ctx().messages().at("admin.edit.removeFinalAllocation"));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        allocation.delete();
        return redirect(controllers.routes.AdminPageController.resultsPage());
    }

    /**
     * Diese Methode macht die letzte Editierung rückgängig. Dies ist jedoch
     * nicht session-übergreifend möglich. Der Administrator wird anschließend
     * auf die Seite zur Einteilungs-Bearbeitung zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result undoAllocationEdit() {
        if (undoStack.isEmpty()) {
            // TODO Button ausgrauen
            flash("error", ctx().messages().at(INTERNAL_ERROR));
            return redirect(
                    controllers.routes.AdminPageController.resultsPage());
        }
        undoStack.pop().undo();
        return redirect(controllers.routes.AdminPageController.resultsPage());
    }
}
