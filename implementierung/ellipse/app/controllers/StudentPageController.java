// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package controllers;

import java.util.ArrayList;
import java.util.List;

import com.google.inject.Inject;

import data.Achievement;
import data.ElipseModel;
import data.GeneralData;
import data.LearningGroup;
import data.Project;
import data.Rating;
import data.SPO;
import data.Semester;
import data.Student;
import data.User;
import play.data.DynamicForm;
import play.data.FormFactory;
import play.mvc.Controller;
import play.mvc.Result;
import security.BlowfishPasswordEncoder;
import security.UserManagement;
import views.Menu;
import views.StudentMenu;

/************************************************************/
/**
 * Dieser Controller ist zuständig für alle Http-Requests, welche im
 * Studentenbereich aufkommen. Dazu zählen das Senden einer neuen HTML-Seite bei
 * einem Klick auf einen Link, als auch das Reagieren auf Benutzereingaben, wie
 * das Abschicken eines Formulars.
 */
public class StudentPageController extends Controller {

    @Inject
    FormFactory formFactory;

    /**
     * 
     * @return
     */
    public Result checkStudent() {
        // TODO checken ob alter student oder neuer und passend weiterleiten
        //
        return null;
    }

    public Result changeFormPage(String error) {
        play.twirl.api.Html content = views.html.studentChangeData.render(
                GeneralData.loadInstance().getCurrentSemester().getSpos(),
                error);
        Menu menu = new Menu();
        return ok(views.html.student.render(menu, content));
    }

    public Result changeData() {
        DynamicForm form = formFactory.form().bindFromRequest();
        if (form.data().size() == 0) {
            return badRequest("Expceting some data");
        } else {
            // die felder werden ausgelesen
            String firstName = form.get("firstName");
            String lastName = form.get("lastName");
            String email = form.get("email");
            String password = form.get("pw");
            String pwRepeat = form.get("rpw");
            String matNrString = "";
            String semesterString = form.get("semester");
            String spoIdString = form.get("spo");
            int spoId;
            int semester = -1;
            int matNr = -1;
            try {
                // die matrikelnummer wird geparst
                matNrString = form.get("matrnr");
                matNr = Integer.parseInt(matNrString);
                semester = Integer.parseInt(semesterString);
                spoId = Integer.parseInt(spoIdString);
                SPO spo = ElipseModel.getById(SPO.class, spoId);
                boolean trueData = false;

                if (form.get("trueData") != null) {
                    // wenn der student angekreuzt hat das seine Angaben der
                    // Wahrheit entsprechen
                    trueData = true;
                }
                List<Achievement> completedAchievements = new ArrayList<>();
                List<Achievement> nonCompletedAchievements = new ArrayList<>();
                try {
                    completedAchievements = MultiselectList
                            .createAchievementList(form, "completed-"
                                    + spoIdString + "-multiselect");
                } catch (NumberFormatException e) {
                    return redirect(controllers.routes.IndexPageController
                            .registerPage(ctx().messages()
                                    .at("error.internalError")));
                }
                try {
                    nonCompletedAchievements = MultiselectList
                            .createAchievementList(form,
                                    "due-" + spoIdString + "-multiselect");
                } catch (NumberFormatException e) {
                    return redirect(controllers.routes.IndexPageController
                            .registerPage(ctx().messages()
                                    .at("error.internalError")));
                }

                if (password.equals(pwRepeat) && trueData) {
                    // wenn der student bestätigt hat das seine angaben richtig
                    // sind und die passwörter übereinstimmen wird ein neuer
                    // student hinzugefügt
                    if (Student.getStudent(matNr) == null) {
                        String encPassword = new BlowfishPasswordEncoder()
                                .encode(password);
                        Student student = new Student(matNrString, encPassword,
                                email, firstName, lastName, matNr, spo,
                                completedAchievements, nonCompletedAchievements,
                                semester);
                        student.save();
                        // TODO get student data from view
                        Semester currentSemester = GeneralData.loadInstance()
                                .getCurrentSemester();
                        currentSemester.doTransaction(() -> {
                            currentSemester.addStudent(student);
                        });
                        return redirect(controllers.routes.IndexPageController
                                .indexPage("error"));
                        // TODO falls nötig noch emial verification einleiten
                    } else {

                        // falls bereits ein studnent mit dieser matrikelnumer
                        // im system existiert kann sich der student nicht
                        // registrieren
                        return redirect(controllers.routes.IndexPageController
                                .registerPage(ctx().messages().at(
                                        "index.registration.error.matNrExists")));
                    }
                }

                // TODO braucht man hmehr als nur eine gererelle fehlermeldung?
                return redirect(controllers.routes.IndexPageController
                        .registerPage(ctx().messages()
                                .at("index.registration.error.genError")));

            } catch (NumberFormatException e) {
                return redirect(controllers.routes.IndexPageController
                        .registerPage(ctx().messages()
                                .at("index.registration.error.genError")));

            }
        }
    }

    /**
     * Diese Methode gibt die Seite zurück, auf der der Student sieht in welcher
     * Lerngruppe er ist, oder wenn er in keiner aktuell ist, eine erstellen
     * oder einer beitreten kann.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result learningGroupPage(String error) {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        play.twirl.api.Html content = views.html.studentLearningGroup
                .render(GeneralData.loadInstance().getCurrentSemester()
                        .getLearningGroupOf(student), error);
        Menu menu = new StudentMenu(ctx(), ctx().request().path());
        return ok(views.html.student.render(menu, content));
    }

    /**
     * Diese Methode gibt die Seite zurück, auf der der Student seine
     * Bewertungen abgeben kann.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result ratingPage(String error) {
        play.twirl.api.Html content = views.html.studentRating.render(
                GeneralData.loadInstance().getCurrentSemester().getProjects(),
                error);
        Menu menu = new StudentMenu(ctx(), ctx().request().path());
        return ok(views.html.student.render(menu, content));
    }

    /**
     * Diese Methode gibt die Seite zurück, auf der der Student das Ergebnis der
     * Einteilungsberechnung einsehen kann. Er sieht also sein Projekt und seine
     * Teammitglieder.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result resultsPage(String error) {
        if (GeneralData.loadInstance().getCurrentSemester()
                .getFinalAllocation() == null) {
            play.twirl.api.Html content = views.html.noAllocationYet.render();
            Menu menu = new StudentMenu(ctx(), ctx().request().path());
            return ok(views.html.student.render(menu, content));

        }
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        play.twirl.api.Html content = views.html.studentResult
                .render(GeneralData.loadInstance().getCurrentSemester()
                        .getFinalAllocation().getTeam(student), error);
        Menu menu = new StudentMenu(ctx(), ctx().request().path());
        return ok(views.html.student.render(menu, content));
    }

    /**
     * Diese Methode fügt die Daten der Bewertungen eines Studenten in das
     * System ein und leitet den Studenten wieder zurück auf die
     * Bewertungsseite, wo er nun seine eingegebene Bewertungen sehen kann.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result rate() {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        DynamicForm form = formFactory.form().bindFromRequest();
        LearningGroup lg = GeneralData.loadInstance().getCurrentSemester()
                .getLearningGroupOf(student);
        lg.doTransaction(() -> {
            ArrayList<Rating> ratings = new ArrayList<>();
            for (Project project : GeneralData.loadInstance()
                    .getCurrentSemester().getProjects()) {
                Rating rating = new Rating(
                        Integer.parseInt(
                                form.get(Integer.toString(project.getId()))),
                        project);
                // holt sich das rating des studenten aus dem formular
                ratings.add(rating);
            }
            lg.setRatings(ratings);
        });
        return redirect(
                controllers.routes.StudentPageController.learningGroupPage(""));
    }

    /**
     * Diese Methode erstellt eine neue Lerngruppe im System und fügt den
     * Ersteller der Lerngruppe als erstes Mitglied in diese ein. Der Student
     * wird anschließend auf die Lerngruppen-Seite zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result createLearningGroup() {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        DynamicForm form = formFactory.form().bindFromRequest();
        String name = form.get("learningGroupname");
        String password = form.get("learningGroupPassword");
        // TODO stimmt hier der rückgabewert in html
        Semester semester = GeneralData.loadInstance().getCurrentSemester();
        LearningGroup learningGroup = LearningGroup.getLearningGroup(name,
                semester);
        if (learningGroup != null) {
            return redirect(controllers.routes.StudentPageController
                    .learningGroupPage(ctx().messages().at(
                            "student .learningGroup.error.existsAllready")));
        }
        if (!semester.getLearningGroupOf(student).isPrivate()) {
            // TODO error
        }
        if (name.matches("\\d*")) {
            // TODO error
        }
        LearningGroup lg = new LearningGroup(name, password, student, false);
        lg.save();
        // Lösche die private Lerngruppe
        semester.getLearningGroupOf(student).delete();
        semester.refresh();
        semester.doTransaction(() -> {
            // TODO falls man die alten bewertungen wieder will muss man hier
            // die alte lerngruppe behalten
            semester.addLearningGroup(lg);
        });
        return redirect(
                controllers.routes.StudentPageController.learningGroupPage(""));
    }

    /**
     * Diese Methode entfernt den Student aus der aktuellen Lerngruppe.
     * Anschließend wird der Student auf die Lerngruppen-Seite zurück geleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result leaveLearningGroup() {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        LearningGroup lg = GeneralData.loadInstance().getCurrentSemester()
                .getLearningGroupOf(student);
        if (lg.isPrivate()) {
            // TODO error
        }
        if (lg.getMembers().size() == 1) {
            // Leeres Team löschen
            lg.delete();
        }
        // Hier wird der student wieder in seine privat Lerngruppe
        // eingefügt
        LearningGroup lgNew = new LearningGroup(student.getUserName(), "",
                student, true);
        lgNew.save();
        Semester semester = GeneralData.loadInstance().getCurrentSemester();
        semester.doTransaction(() -> {
            semester.addLearningGroup(lgNew);
        });

        lg.doTransaction(() -> {
            lg.removeMember(student);
        });
        return redirect(
                controllers.routes.StudentPageController.learningGroupPage(""));

    }

    /**
     * Diese Methode fügt den Studenten zu einer Lerngruppe hinzu, falls eine
     * Lerngruppe mit dem Namen und dem zugehörigen Passwort existiert und die
     * Lerngruppe noch nicht größergleich der maximalen Lerngruppenqröße ist .
     * Anschließend wird der Student auf die Lerngruppen-Seite zurückgeleitet.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result joinLearningGroup() {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        DynamicForm form = formFactory.form().bindFromRequest();
        String name = form.get("learningGroupname");
        String pw = form.get("learningGroupPassword");
        LearningGroup lgOld = GeneralData.loadInstance().getCurrentSemester()
                .getLearningGroupOf(student);
        LearningGroup lgNew = LearningGroup.getLearningGroup(name,
                GeneralData.loadInstance().getCurrentSemester());
        // Wenn die Lerngruppe bereits voll ist, wird ein Fehler zurückgegeben
        if (lgNew.getMembers().size() >= GeneralData.loadInstance()
                .getCurrentSemester().getMaxGroupSize()) {
            return redirect(controllers.routes.StudentPageController
                    .learningGroupPage(ctx().messages().at(
                            "student .learningGroup.error.learningGroupFull")));
        }
        if (!lgOld.isPrivate()) {
            // TODO error
        }
        if (lgNew.isPrivate()) {
            // TODO error
        }

        if (lgNew.getPassword().equals(pw)) {
            lgOld.delete(); // die private lerngruppe wird gelöscht
            lgNew.doTransaction(() -> {
                lgNew.addMember(student);
            });
            return redirect(controllers.routes.StudentPageController
                    .learningGroupPage(""));
        } else {
            return redirect(controllers.routes.StudentPageController
                    .learningGroupPage(ctx().messages()
                            .at("student .learningGroup.error.wrongPW")));
        }
    }

    /**
     * Diese Methode gibt die Seite zurück, auf der der Student seine
     * Studentendaten wie E-Mail-Adresse und Passwort ändern kann.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result accountPage(String error) {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        play.twirl.api.Html content = views.html.studentAccount.render(student,
                error);
        Menu menu = new StudentMenu(ctx(), ctx().request().path());
        return ok(views.html.student.render(menu, content));
    }

    /**
     * Diese Methode editiert die Daten des Studenten, welche er auf der
     * Account-Seite geändert hat.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result editAccount() {
        UserManagement user = new UserManagement();
        User userProfile = user.getUserProfile(ctx());
        assert userProfile instanceof Student;
        Student student = (Student) userProfile;
        DynamicForm form = formFactory.form().bindFromRequest();

        if (form.get("passwordChange") != null) {
            String oldpw = form.get("oldPassword");
            String pw = form.get("newPassword");
            String pwrepeat = form.get("newPasswordRepeat");

            boolean matches = new BlowfishPasswordEncoder().matches(oldpw,
                    student.getPassword());

            if (!pw.equals(pwrepeat) || !matches) {
                // TODO error message
                return redirect(controllers.routes.StudentPageController
                        .accountPage("error"));
            }
            String pwEnc = new BlowfishPasswordEncoder().encode(pw);
            student.doTransaction(() -> {
                student.setPassword(pwEnc);
            });
        }
        if (form.get("emailChange") != null) {
            String email = form.get("newEmail");
            student.doTransaction(() -> {
                student.setEmailAddress(email);
            });
            // TODO hier verifikation
        }
        return redirect(
                controllers.routes.StudentPageController.accountPage(""));
    }

    /**
     * Diese Methode verschickt einen neuen Verifikations-Code an die aktuelle
     * E-Mail-Adresse.
     * 
     * @return Die Seite, die als Antwort verschickt wird.
     */
    public Result sendNewVerificationLink() {
        // TODO: Verifkationscode neu erstellen und senden
        return redirect(
                controllers.routes.StudentPageController.accountPage(""));
    }
}
