// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package allocation;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.ServiceLoader;

import data.Allocation;
import data.AllocationParameter;
import data.GeneralData;
import data.Team;
import gurobi.GRB;
import gurobi.GRB.DoubleAttr;
import gurobi.GRBEnv;
import gurobi.GRBException;
import gurobi.GRBLinExpr;
import gurobi.GRBModel;
import gurobi.GRBVar;

/************************************************************/
/**
 * Der Gurobi Allocator dient zur Berechnung einer Einteilung mit dem ILP Solver
 * Gurobi. Weiterhin stellt er ein Basismodell und einen Optimierungsterm zur
 * Verfügung, welche von den Kriterien verwendet werden.
 */
public class GurobiAllocator extends AbstractAllocator {

    /**
     * String-Konstante für Gurobi
     */
    public static final String  NULL     = "";

    private static final String MIN_SIZE = "minSize";

    private static final String MAX_SIZE = "maxSize";

    /**
     * Die Basismatrix (NxM), welche anzeigt, ob ein Student n in einem Team m
     * ist. Die Mte Spalte ist das Team der nicht Zugeteilten.
     */
    private GRBVar[][]          basicMatrix;
    /**
     * Über Constraints dynamisch bestimmte Teamgröße. (Hilfsvariablen)
     */
    private GRBVar[]            teamSizes;
    /**
     * Der Optimierungsterm der von Kriterien erweitert wird und zur Berechnung
     * der Einteilung verwendet wird.
     */
    private GRBLinExpr          optTerm;
    /**
     * Das zur Berechnung verwendete Gurobi Model.
     */
    private GRBModel            model;

    private GRBEnv              env;

    private Configuration       currentConfiguration;

    /**
     * Konstruktor, der das Basismodell initialisiert.
     */
    public GurobiAllocator() {

    }

    /**
     * Getter für die Basismatrix.
     * 
     * @return Die Basismatrix
     */
    public GRBVar[][] getBasicMatrix() {
        return this.basicMatrix;
    }

    /**
     * Getter für das Modell.
     * 
     * @return Das Modell
     */
    public GRBModel getModel() {
        return this.model;
    }

    /**
     * Getter für den Optimierungsterm.
     * 
     * @return Der Optimierungsterm
     */
    public GRBLinExpr getOptimizationTerm() {
        return optTerm;
    }

    /**
     * Getter für die, über Constraints bestimmten, Teamgrößen
     * 
     * @return Array von Teamgrößen
     */
    public GRBVar[] getTeamSizes() {
        return this.teamSizes;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void init(Configuration configuration) {
        synchronized (this) {
            currentConfiguration = configuration;
            try {
                env = new GRBEnv();
                model = makeModel(currentConfiguration, env);
            } catch (GRBException e) {
                Allocation failure = nullObject("allocation.gurobiException");
                failure.save();
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void calculate() {
        if (null == this.model) {
            System.out.println("Calculate was called before init. This is prohibited.");
            assert false;// calculate() wurde vor init() aufgerufen: Das darf
                         // nicht sein! TODO
            return;
        }
        // Hier wird die eigentliche Berechnung durchgeführt
        try {
            this.model.optimize();
        } catch (GRBException e) {
            System.out.println("1");
            Allocation failure = nullObject("allocation.gurobiException");
            failure.save();
            return;
        } catch (NoSuchElementException e) {
            System.out.println("2");
            Allocation failure = nullObject("allocation.parameterNotFound");
            failure.save();
            return;
        }
        // erstelle Teams
        for (int i = 0; i < currentConfiguration.getTeams().size(); i++) {
            for (int j = 0; j < currentConfiguration.getStudents().size(); j++) {
                double result;
                try {
                    result = this.basicMatrix[j][i].get(DoubleAttr.X);
                } catch (GRBException e) {
                    System.out.println("3");
                    Allocation failure = nullObject("allocation.gurobiException");
                    failure.save();
                    return;
                }
                if (result == 1) {
                    currentConfiguration.getTeams().get(i).addMember(currentConfiguration.getStudents().get(j));
                }
            }
        }
        // Mache Environment und Model ungültig
        try {
            this.model.dispose();
            env.dispose();
        } catch (GRBException e) {
            System.out.println("4");
            Allocation failure = nullObject("allocation.gurobiException");
            failure.save();
            return;
        }

        // Erstelle Einteilung
        Allocation allocation = new Allocation(currentConfiguration.getTeams(), currentConfiguration.getName(),
                currentConfiguration.getParameters());
        allocation.doTransaction(() -> {
            allocation.setSemester(GeneralData.loadInstance().getCurrentSemester());
        });

    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void cancel() {
        synchronized (this) {
            if (null != this.model) {
                this.model.terminate();
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<GurobiCriterion> getAllCriteria() {
        Iterator<GurobiCriterion> iter = ServiceLoader.load(GurobiCriterion.class).iterator();
        ArrayList<GurobiCriterion> criteria = new ArrayList<GurobiCriterion>();
        while (iter.hasNext()) {
            criteria.add(iter.next());
        }
        return criteria;
    }

    private GRBModel makeModel(Configuration configuration, GRBEnv env) throws GRBException, NoSuchElementException {
        GRBModel model = new GRBModel(env);

        // Erstelle Basismatrix B
        this.basicMatrix = new GRBVar[configuration.getStudents().size()][configuration.getTeams().size() + 1];
        for (int i = 0; i < configuration.getStudents().size(); i++) {
            for (int j = 0; j <= configuration.getTeams().size(); j++) {
                this.basicMatrix[i][j] = model.addVar(0, 1, 0, GRB.BINARY, NULL);
            }
        }

        // Erzeuge Basisconstraint
        // Genau 1 Team pro Student

        for (int i = 0; i < configuration.getStudents().size(); i++) {
            GRBLinExpr teamsPerStudent = new GRBLinExpr();
            for (int j = 0; j <= configuration.getTeams().size(); j++) {
                teamsPerStudent.addTerm(1, this.basicMatrix[i][j]);
            }
            model.addConstr(teamsPerStudent, GRB.EQUAL, 1, NULL);
        }

        // Erzeuge Teamgröße-Variablen

        this.teamSizes = new GRBVar[configuration.getTeams().size()];

        for (int i = 0; i < configuration.getTeams().size(); i++) {
            teamSizes[i] = model.addVar(0, Double.MAX_VALUE, 0, GRB.INTEGER, NULL);
            GRBLinExpr teamSum = new GRBLinExpr();
            for (int j = 0; j < configuration.getStudents().size(); j++) {
                teamSum.addTerm(1, this.basicMatrix[j][i]);
            }
            model.addConstr(teamSizes[i], GRB.EQUAL, teamSum, NULL);
        }

        // Bestimme die vom Admin eingestellte min- und max-Größe
        List<AllocationParameter> parameters = configuration.getParameters();
        double minAdminSize;
        double maxAdminSize;
        minAdminSize = parameters.stream().filter(parameter -> parameter.getName().equals(MIN_SIZE)).findFirst().get()
                .getValue();
        maxAdminSize = parameters.stream().filter(parameter -> parameter.getName().equals(MAX_SIZE)).findFirst().get()
                .getValue();

        // Teamgröße zwischen min und max, oder 0
        for (int i = 0; i < configuration.getTeams().size(); i++) {
            GRBVar correctTeamSize = model.addVar(0, 1, 0, GRB.BINARY, NULL);

            GRBLinExpr secondConstraintRightSide = new GRBLinExpr();
            GRBLinExpr thirdConstraintRightSide = new GRBLinExpr();

            secondConstraintRightSide.addTerm(getMaxSize(configuration.getTeams().get(i), maxAdminSize),
                    correctTeamSize);

            thirdConstraintRightSide.addTerm(getMinSize(configuration.getTeams().get(i), minAdminSize),
                    correctTeamSize);

            model.addConstr(correctTeamSize, GRB.LESS_EQUAL, this.teamSizes[i], NULL);
            model.addConstr(this.teamSizes[i], GRB.LESS_EQUAL, secondConstraintRightSide, NULL);
            model.addConstr(this.teamSizes[i], GRB.GREATER_EQUAL, thirdConstraintRightSide, NULL);
        }

        this.model = model;

        // Initialisiere Optimierungsterm
        this.optTerm = new GRBLinExpr();

        // füge Kriterien hinzu
        List<GurobiCriterion> criteria = getAllCriteria();
        for (GurobiCriterion criterion : criteria) {

            // Finde den vom Admin eingegebenen Parameter
            double weight;
            // TODO Ist die Abfrage auf null nötig? Kann das überhaupt
            // passieren?
            AllocationParameter param = configuration.getParameters().stream()
                    .filter(parameter -> parameter.getName().equals(criterion.getName())).findFirst().orElse(null);
            if (null != param) {
                weight = param.getValue();
                if (weight != 0) {
                    criterion.useCriteria(configuration, this, weight);
                }
            }

        }

        // Stelle Modell auf Maximierung ein
        model.setObjective(this.optTerm, GRB.MAXIMIZE);

        return model;
    }

    /**
     * Berechne minimale Teamgröße
     * 
     * @param team
     *            Das Team
     * @param minAdminSize
     *            Die vom Admin eingestellte Größe
     * @return Die Teamgröße
     */
    private int getMinSize(Team team, double minAdminSize) {
        if (team.getProject().getMinTeamSize() == -1) {
            return (int) minAdminSize;
        } else {
            return team.getProject().getMinTeamSize();
        }
    }

    /**
     * Berechne maximale Teamgröße
     * 
     * @param team
     *            Das Team
     * @param minAdminSize
     *            Die vom Admin eingestellte Größe
     * @return Die Teamgröße
     */
    private int getMaxSize(Team team, double maxAdminSize) {
        if (team.getProject().getMaxTeamSize() == -1) {
            return (int) maxAdminSize;
        } else {
            return team.getProject().getMaxTeamSize();
        }
    }

    private Allocation nullObject(String errorMessage) {
        Allocation failedAllocation = new Allocation(new ArrayList<Team>(), errorMessage,
                new ArrayList<AllocationParameter>());
        System.out.println("ERROR");
        return failedAllocation;
    }
}
