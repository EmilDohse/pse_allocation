// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package allocation;

import java.util.List;
import java.util.stream.Collectors;

import data.LearningGroup;
import exception.AllocationException;
import gurobi.GRB;
import gurobi.GRBException;
import gurobi.GRBLinExpr;
import gurobi.GRBVar;

/************************************************************/
/**
 * Das Kriterium sorgt dafür, dass Lerngruppen eher zusammenbleiben.
 */
public class CriterionLearningGroup implements GurobiCriterion {
	private String name;

	/**
	 * Standard-Konstruktor, der den Namen eindeutig setzt
	 */
	public CriterionLearningGroup() {
		this.name = "LearningGroups";
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getName() {
		return this.name;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void useCriteria(Configuration configuration, GurobiAllocator allocator, double weight)
			throws AllocationException {
		GRBLinExpr bonus = new GRBLinExpr();

		// Betrachte nur Lerngruppen mit mehr als einem Mitglied
		List<LearningGroup> bigGroups = configuration.getLearningGroups().stream()
				.filter(lg -> lg.getMembers().size() > 1).collect(Collectors.toList());
		for (LearningGroup lg : bigGroups) {
			double pairs = ((lg.getMembers().size() - 1) * lg.getMembers().size()) / 2;

			// Schleife durchläuft alle Paare von Studenten in der Lerngruppe
			for (int i = 0; i < lg.getMembers().size() - 1; i++) {
				for (int j = i + 1; j < lg.getMembers().size(); j++) {

					// finde Indizes der Mitglieder in Studentenliste
					int firstStudentIndex = configuration.getStudents().indexOf(lg.getMembers().get(i));
					int secondStudentIndex = configuration.getStudents().indexOf(lg.getMembers().get(j));

					// Durchlaufe für jedes Paar, jedes Team
					for (int t = 0; t < configuration.getTeams().size(); t++) {
						GRBVar pairInSameTeam;
						try {
							pairInSameTeam = allocator.getModel().addVar(0, 1, 0, GRB.BINARY, GurobiAllocator.NULL);
						} catch (GRBException e) {
							throw new AllocationException("allocation.gurobiException");
						}

						// Benötigte Teilterme für AND-Verknüpfung
						GRBLinExpr leftSideFirstConstraint = new GRBLinExpr();
						GRBLinExpr leftSideSecondConstraint = new GRBLinExpr();

						leftSideFirstConstraint.addTerm(1, allocator.getBasicMatrix()[firstStudentIndex][t]);
						leftSideFirstConstraint.addTerm(1, allocator.getBasicMatrix()[secondStudentIndex][t]);
						leftSideFirstConstraint.addTerm(-2, pairInSameTeam);

						leftSideSecondConstraint.addTerm(2, pairInSameTeam);
						leftSideSecondConstraint.addTerm(-1, allocator.getBasicMatrix()[firstStudentIndex][t]);
						leftSideSecondConstraint.addTerm(-1, allocator.getBasicMatrix()[secondStudentIndex][t]);

						try {
							allocator.getModel().addConstr(leftSideFirstConstraint, GRB.LESS_EQUAL, 1,
									GurobiAllocator.NULL);
							allocator.getModel().addConstr(leftSideSecondConstraint, GRB.LESS_EQUAL, 0,
									GurobiAllocator.NULL);
						} catch (GRBException e) {
							throw new AllocationException("allocation.gurobiException");
						}

						bonus.addTerm(weight * (10 / pairs), pairInSameTeam);
					}
				}
			}
		}
		try {
			allocator.getOptimizationTerm().add(bonus);
		} catch (GRBException e) {
			throw new AllocationException("allocation.gurobiException");
		}
	}
}